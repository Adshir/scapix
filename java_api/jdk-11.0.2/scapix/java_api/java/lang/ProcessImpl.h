// Generated by Scapix Java API
// https://www.scapix.com

#include <scapix/java_api/java/lang/Process.h>

#ifndef SCAPIX_JAVA_LANG_PROCESSIMPL_H
#define SCAPIX_JAVA_LANG_PROCESSIMPL_H

namespace scapix::java_api {

namespace java::io { class InputStream; }
namespace java::io { class OutputStream; }
namespace java::lang { class ProcessHandle; }
namespace java::lang { class String; }
namespace java::util::concurrent { class CompletableFuture; }
namespace java::util::concurrent { class TimeUnit; }

namespace java::lang {

// private
class ProcessImpl : public object_base<SCAPIX_META_STRING("java/lang/ProcessImpl"),
	java::lang::Process>
{
public:

	ref<java::io::OutputStream> getOutputStream();
	ref<java::io::InputStream> getInputStream();
	ref<java::io::InputStream> getErrorStream();
	jint exitValue();
	jint waitFor();
	jboolean waitFor(jlong timeout, ref<java::util::concurrent::TimeUnit> p2);
	void destroy();
	ref<java::util::concurrent::CompletableFuture> onExit();
	ref<java::lang::ProcessHandle> toHandle();
	jboolean supportsNormalTermination();
	ref<java::lang::Process> destroyForcibly();
	jlong pid();
	jboolean isAlive();
	ref<java::lang::String> toString();

protected:

	ProcessImpl(handle_type h) : base_(h) {}

};

} // namespace java::lang
} // namespace scapix::java_api

#include <scapix/java_api/java/io/InputStream.h>
#include <scapix/java_api/java/io/OutputStream.h>
#include <scapix/java_api/java/lang/ProcessHandle.h>
#include <scapix/java_api/java/lang/String.h>
#include <scapix/java_api/java/util/concurrent/CompletableFuture.h>
#include <scapix/java_api/java/util/concurrent/TimeUnit.h>

namespace scapix::java_api {
namespace java::lang {

inline ref<java::io::OutputStream> ProcessImpl::getOutputStream() { return call_method<SCAPIX_META_STRING("getOutputStream"), ref<java::io::OutputStream>>(); }
inline ref<java::io::InputStream> ProcessImpl::getInputStream() { return call_method<SCAPIX_META_STRING("getInputStream"), ref<java::io::InputStream>>(); }
inline ref<java::io::InputStream> ProcessImpl::getErrorStream() { return call_method<SCAPIX_META_STRING("getErrorStream"), ref<java::io::InputStream>>(); }
inline jint ProcessImpl::exitValue() { return call_method<SCAPIX_META_STRING("exitValue"), jint>(); }
inline jint ProcessImpl::waitFor() { return call_method<SCAPIX_META_STRING("waitFor"), jint>(); }
inline jboolean ProcessImpl::waitFor(jlong timeout, ref<java::util::concurrent::TimeUnit> p2) { return call_method<SCAPIX_META_STRING("waitFor"), jboolean>(timeout, p2); }
inline void ProcessImpl::destroy() { return call_method<SCAPIX_META_STRING("destroy"), void>(); }
inline ref<java::util::concurrent::CompletableFuture> ProcessImpl::onExit() { return call_method<SCAPIX_META_STRING("onExit"), ref<java::util::concurrent::CompletableFuture>>(); }
inline ref<java::lang::ProcessHandle> ProcessImpl::toHandle() { return call_method<SCAPIX_META_STRING("toHandle"), ref<java::lang::ProcessHandle>>(); }
inline jboolean ProcessImpl::supportsNormalTermination() { return call_method<SCAPIX_META_STRING("supportsNormalTermination"), jboolean>(); }
inline ref<java::lang::Process> ProcessImpl::destroyForcibly() { return call_method<SCAPIX_META_STRING("destroyForcibly"), ref<java::lang::Process>>(); }
inline jlong ProcessImpl::pid() { return call_method<SCAPIX_META_STRING("pid"), jlong>(); }
inline jboolean ProcessImpl::isAlive() { return call_method<SCAPIX_META_STRING("isAlive"), jboolean>(); }
inline ref<java::lang::String> ProcessImpl::toString() { return call_method<SCAPIX_META_STRING("toString"), ref<java::lang::String>>(); }

} // namespace java::lang
} // namespace scapix::java_api

#endif // SCAPIX_JAVA_LANG_PROCESSIMPL_H
