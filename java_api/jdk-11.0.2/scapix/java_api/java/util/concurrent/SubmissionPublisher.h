// Generated by Scapix Java API
// https://www.scapix.com

#include <scapix/java_api/java/lang/Object.h>
#include <scapix/java_api/java/util/concurrent/Flow_Publisher.h>
#include <scapix/java_api/java/lang/AutoCloseable.h>

#ifndef SCAPIX_JAVA_UTIL_CONCURRENT_SUBMISSIONPUBLISHER_H
#define SCAPIX_JAVA_UTIL_CONCURRENT_SUBMISSIONPUBLISHER_H

namespace scapix::java_api {

namespace java::lang { class Throwable; }
namespace java::util { class List; }
namespace java::util::concurrent { class CompletableFuture; }
namespace java::util::concurrent { class Executor; }
namespace java::util::concurrent { class Flow_Subscriber; }
namespace java::util::concurrent { class TimeUnit; }
namespace java::util::function { class BiConsumer; }
namespace java::util::function { class BiPredicate; }
namespace java::util::function { class Consumer; }

namespace java::util::concurrent {

class SubmissionPublisher : public object_base<SCAPIX_META_STRING("java/util/concurrent/SubmissionPublisher"),
	java::lang::Object,
	java::util::concurrent::Flow_Publisher,
	java::lang::AutoCloseable>
{
public:

	static ref<SubmissionPublisher> new_object(ref<java::util::concurrent::Executor> executor, jint maxBufferCapacity, ref<java::util::function::BiConsumer> handler);
	static ref<SubmissionPublisher> new_object(ref<java::util::concurrent::Executor> executor, jint maxBufferCapacity);
	static ref<SubmissionPublisher> new_object();
	void subscribe(ref<java::util::concurrent::Flow_Subscriber> subscriber);
	jint submit(ref<java::lang::Object> item);
	jint offer(ref<java::lang::Object> item, ref<java::util::function::BiPredicate> onDrop);
	jint offer(ref<java::lang::Object> item, jlong timeout, ref<java::util::concurrent::TimeUnit> p3, ref<java::util::function::BiPredicate> unit);
	void close();
	void closeExceptionally(ref<java::lang::Throwable> error);
	jboolean isClosed();
	ref<java::lang::Throwable> getClosedException();
	jboolean hasSubscribers();
	jint getNumberOfSubscribers();
	ref<java::util::concurrent::Executor> getExecutor();
	jint getMaxBufferCapacity();
	ref<java::util::List> getSubscribers();
	jboolean isSubscribed(ref<java::util::concurrent::Flow_Subscriber> subscriber);
	jlong estimateMinimumDemand();
	jint estimateMaximumLag();
	ref<java::util::concurrent::CompletableFuture> consume(ref<java::util::function::Consumer> consumer);

protected:

	SubmissionPublisher(handle_type h) : base_(h) {}

};

} // namespace java::util::concurrent
} // namespace scapix::java_api

#include <scapix/java_api/java/lang/Throwable.h>
#include <scapix/java_api/java/util/List.h>
#include <scapix/java_api/java/util/concurrent/CompletableFuture.h>
#include <scapix/java_api/java/util/concurrent/Executor.h>
#include <scapix/java_api/java/util/concurrent/Flow_Subscriber.h>
#include <scapix/java_api/java/util/concurrent/TimeUnit.h>
#include <scapix/java_api/java/util/function/BiConsumer.h>
#include <scapix/java_api/java/util/function/BiPredicate.h>
#include <scapix/java_api/java/util/function/Consumer.h>

namespace scapix::java_api {
namespace java::util::concurrent {

inline ref<SubmissionPublisher> SubmissionPublisher::new_object(ref<java::util::concurrent::Executor> executor, jint maxBufferCapacity, ref<java::util::function::BiConsumer> handler) { return base_::new_object(executor, maxBufferCapacity, handler); }
inline ref<SubmissionPublisher> SubmissionPublisher::new_object(ref<java::util::concurrent::Executor> executor, jint maxBufferCapacity) { return base_::new_object(executor, maxBufferCapacity); }
inline ref<SubmissionPublisher> SubmissionPublisher::new_object() { return base_::new_object(); }
inline void SubmissionPublisher::subscribe(ref<java::util::concurrent::Flow_Subscriber> subscriber) { return call_method<SCAPIX_META_STRING("subscribe"), void>(subscriber); }
inline jint SubmissionPublisher::submit(ref<java::lang::Object> item) { return call_method<SCAPIX_META_STRING("submit"), jint>(item); }
inline jint SubmissionPublisher::offer(ref<java::lang::Object> item, ref<java::util::function::BiPredicate> onDrop) { return call_method<SCAPIX_META_STRING("offer"), jint>(item, onDrop); }
inline jint SubmissionPublisher::offer(ref<java::lang::Object> item, jlong timeout, ref<java::util::concurrent::TimeUnit> p3, ref<java::util::function::BiPredicate> unit) { return call_method<SCAPIX_META_STRING("offer"), jint>(item, timeout, p3, unit); }
inline void SubmissionPublisher::close() { return call_method<SCAPIX_META_STRING("close"), void>(); }
inline void SubmissionPublisher::closeExceptionally(ref<java::lang::Throwable> error) { return call_method<SCAPIX_META_STRING("closeExceptionally"), void>(error); }
inline jboolean SubmissionPublisher::isClosed() { return call_method<SCAPIX_META_STRING("isClosed"), jboolean>(); }
inline ref<java::lang::Throwable> SubmissionPublisher::getClosedException() { return call_method<SCAPIX_META_STRING("getClosedException"), ref<java::lang::Throwable>>(); }
inline jboolean SubmissionPublisher::hasSubscribers() { return call_method<SCAPIX_META_STRING("hasSubscribers"), jboolean>(); }
inline jint SubmissionPublisher::getNumberOfSubscribers() { return call_method<SCAPIX_META_STRING("getNumberOfSubscribers"), jint>(); }
inline ref<java::util::concurrent::Executor> SubmissionPublisher::getExecutor() { return call_method<SCAPIX_META_STRING("getExecutor"), ref<java::util::concurrent::Executor>>(); }
inline jint SubmissionPublisher::getMaxBufferCapacity() { return call_method<SCAPIX_META_STRING("getMaxBufferCapacity"), jint>(); }
inline ref<java::util::List> SubmissionPublisher::getSubscribers() { return call_method<SCAPIX_META_STRING("getSubscribers"), ref<java::util::List>>(); }
inline jboolean SubmissionPublisher::isSubscribed(ref<java::util::concurrent::Flow_Subscriber> subscriber) { return call_method<SCAPIX_META_STRING("isSubscribed"), jboolean>(subscriber); }
inline jlong SubmissionPublisher::estimateMinimumDemand() { return call_method<SCAPIX_META_STRING("estimateMinimumDemand"), jlong>(); }
inline jint SubmissionPublisher::estimateMaximumLag() { return call_method<SCAPIX_META_STRING("estimateMaximumLag"), jint>(); }
inline ref<java::util::concurrent::CompletableFuture> SubmissionPublisher::consume(ref<java::util::function::Consumer> consumer) { return call_method<SCAPIX_META_STRING("consume"), ref<java::util::concurrent::CompletableFuture>>(consumer); }

} // namespace java::util::concurrent
} // namespace scapix::java_api

#endif // SCAPIX_JAVA_UTIL_CONCURRENT_SUBMISSIONPUBLISHER_H
