// Generated by Scapix Java API
// https://www.scapix.com

#include <scapix/java_api/java/util/concurrent/AbstractExecutorService.h>

#ifndef SCAPIX_JAVA_UTIL_CONCURRENT_THREADPOOLEXECUTOR_H
#define SCAPIX_JAVA_UTIL_CONCURRENT_THREADPOOLEXECUTOR_H

namespace scapix::java_api {

namespace java::lang { class Runnable; }
namespace java::lang { class String; }
namespace java::util { class List; }
namespace java::util::concurrent { class BlockingQueue; }
namespace java::util::concurrent { class RejectedExecutionHandler; }
namespace java::util::concurrent { class ThreadFactory; }
namespace java::util::concurrent { class TimeUnit; }
namespace java::util::concurrent { class ThreadPoolExecutor_DiscardPolicy; }
namespace java::util::concurrent { class ThreadPoolExecutor_DiscardOldestPolicy; }
namespace java::util::concurrent { class ThreadPoolExecutor_CallerRunsPolicy; }
namespace java::util::concurrent { class ThreadPoolExecutor_AbortPolicy; }

namespace java::util::concurrent {

class ThreadPoolExecutor : public object_base<SCAPIX_META_STRING("java/util/concurrent/ThreadPoolExecutor"),
	java::util::concurrent::AbstractExecutorService>
{
public:

	using DiscardPolicy = ThreadPoolExecutor_DiscardPolicy;
	using DiscardOldestPolicy = ThreadPoolExecutor_DiscardOldestPolicy;
	using CallerRunsPolicy = ThreadPoolExecutor_CallerRunsPolicy;
	using AbortPolicy = ThreadPoolExecutor_AbortPolicy;

	static ref<ThreadPoolExecutor> new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit);
	static ref<ThreadPoolExecutor> new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit, ref<java::util::concurrent::ThreadFactory> workQueue);
	static ref<ThreadPoolExecutor> new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit, ref<java::util::concurrent::RejectedExecutionHandler> workQueue);
	static ref<ThreadPoolExecutor> new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit, ref<java::util::concurrent::ThreadFactory> workQueue, ref<java::util::concurrent::RejectedExecutionHandler> threadFactory);
	void execute(ref<java::lang::Runnable> command);
	void shutdown();
	ref<java::util::List> shutdownNow();
	jboolean isShutdown();
	jboolean isTerminating();
	jboolean isTerminated();
	jboolean awaitTermination(jlong timeout, ref<java::util::concurrent::TimeUnit> p2);
	void setThreadFactory(ref<java::util::concurrent::ThreadFactory> threadFactory);
	ref<java::util::concurrent::ThreadFactory> getThreadFactory();
	void setRejectedExecutionHandler(ref<java::util::concurrent::RejectedExecutionHandler> handler);
	ref<java::util::concurrent::RejectedExecutionHandler> getRejectedExecutionHandler();
	void setCorePoolSize(jint corePoolSize);
	jint getCorePoolSize();
	jboolean prestartCoreThread();
	jint prestartAllCoreThreads();
	jboolean allowsCoreThreadTimeOut();
	void allowCoreThreadTimeOut(jboolean value);
	void setMaximumPoolSize(jint maximumPoolSize);
	jint getMaximumPoolSize();
	void setKeepAliveTime(jlong time, ref<java::util::concurrent::TimeUnit> p2);
	jlong getKeepAliveTime(ref<java::util::concurrent::TimeUnit> unit);
	ref<java::util::concurrent::BlockingQueue> getQueue();
	jboolean remove(ref<java::lang::Runnable> task);
	void purge();
	jint getPoolSize();
	jint getActiveCount();
	jint getLargestPoolSize();
	jlong getTaskCount();
	jlong getCompletedTaskCount();
	ref<java::lang::String> toString();

protected:

	ThreadPoolExecutor(handle_type h) : base_(h) {}

};

} // namespace java::util::concurrent
} // namespace scapix::java_api

#include <scapix/java_api/java/lang/Runnable.h>
#include <scapix/java_api/java/lang/String.h>
#include <scapix/java_api/java/util/List.h>
#include <scapix/java_api/java/util/concurrent/BlockingQueue.h>
#include <scapix/java_api/java/util/concurrent/RejectedExecutionHandler.h>
#include <scapix/java_api/java/util/concurrent/ThreadFactory.h>
#include <scapix/java_api/java/util/concurrent/TimeUnit.h>

namespace scapix::java_api {
namespace java::util::concurrent {

inline ref<ThreadPoolExecutor> ThreadPoolExecutor::new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit) { return base_::new_object(corePoolSize, maximumPoolSize, keepAliveTime, p4, unit); }
inline ref<ThreadPoolExecutor> ThreadPoolExecutor::new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit, ref<java::util::concurrent::ThreadFactory> workQueue) { return base_::new_object(corePoolSize, maximumPoolSize, keepAliveTime, p4, unit, workQueue); }
inline ref<ThreadPoolExecutor> ThreadPoolExecutor::new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit, ref<java::util::concurrent::RejectedExecutionHandler> workQueue) { return base_::new_object(corePoolSize, maximumPoolSize, keepAliveTime, p4, unit, workQueue); }
inline ref<ThreadPoolExecutor> ThreadPoolExecutor::new_object(jint corePoolSize, jint maximumPoolSize, jlong keepAliveTime, ref<java::util::concurrent::TimeUnit> p4, ref<java::util::concurrent::BlockingQueue> unit, ref<java::util::concurrent::ThreadFactory> workQueue, ref<java::util::concurrent::RejectedExecutionHandler> threadFactory) { return base_::new_object(corePoolSize, maximumPoolSize, keepAliveTime, p4, unit, workQueue, threadFactory); }
inline void ThreadPoolExecutor::execute(ref<java::lang::Runnable> command) { return call_method<SCAPIX_META_STRING("execute"), void>(command); }
inline void ThreadPoolExecutor::shutdown() { return call_method<SCAPIX_META_STRING("shutdown"), void>(); }
inline ref<java::util::List> ThreadPoolExecutor::shutdownNow() { return call_method<SCAPIX_META_STRING("shutdownNow"), ref<java::util::List>>(); }
inline jboolean ThreadPoolExecutor::isShutdown() { return call_method<SCAPIX_META_STRING("isShutdown"), jboolean>(); }
inline jboolean ThreadPoolExecutor::isTerminating() { return call_method<SCAPIX_META_STRING("isTerminating"), jboolean>(); }
inline jboolean ThreadPoolExecutor::isTerminated() { return call_method<SCAPIX_META_STRING("isTerminated"), jboolean>(); }
inline jboolean ThreadPoolExecutor::awaitTermination(jlong timeout, ref<java::util::concurrent::TimeUnit> p2) { return call_method<SCAPIX_META_STRING("awaitTermination"), jboolean>(timeout, p2); }
inline void ThreadPoolExecutor::setThreadFactory(ref<java::util::concurrent::ThreadFactory> threadFactory) { return call_method<SCAPIX_META_STRING("setThreadFactory"), void>(threadFactory); }
inline ref<java::util::concurrent::ThreadFactory> ThreadPoolExecutor::getThreadFactory() { return call_method<SCAPIX_META_STRING("getThreadFactory"), ref<java::util::concurrent::ThreadFactory>>(); }
inline void ThreadPoolExecutor::setRejectedExecutionHandler(ref<java::util::concurrent::RejectedExecutionHandler> handler) { return call_method<SCAPIX_META_STRING("setRejectedExecutionHandler"), void>(handler); }
inline ref<java::util::concurrent::RejectedExecutionHandler> ThreadPoolExecutor::getRejectedExecutionHandler() { return call_method<SCAPIX_META_STRING("getRejectedExecutionHandler"), ref<java::util::concurrent::RejectedExecutionHandler>>(); }
inline void ThreadPoolExecutor::setCorePoolSize(jint corePoolSize) { return call_method<SCAPIX_META_STRING("setCorePoolSize"), void>(corePoolSize); }
inline jint ThreadPoolExecutor::getCorePoolSize() { return call_method<SCAPIX_META_STRING("getCorePoolSize"), jint>(); }
inline jboolean ThreadPoolExecutor::prestartCoreThread() { return call_method<SCAPIX_META_STRING("prestartCoreThread"), jboolean>(); }
inline jint ThreadPoolExecutor::prestartAllCoreThreads() { return call_method<SCAPIX_META_STRING("prestartAllCoreThreads"), jint>(); }
inline jboolean ThreadPoolExecutor::allowsCoreThreadTimeOut() { return call_method<SCAPIX_META_STRING("allowsCoreThreadTimeOut"), jboolean>(); }
inline void ThreadPoolExecutor::allowCoreThreadTimeOut(jboolean value) { return call_method<SCAPIX_META_STRING("allowCoreThreadTimeOut"), void>(value); }
inline void ThreadPoolExecutor::setMaximumPoolSize(jint maximumPoolSize) { return call_method<SCAPIX_META_STRING("setMaximumPoolSize"), void>(maximumPoolSize); }
inline jint ThreadPoolExecutor::getMaximumPoolSize() { return call_method<SCAPIX_META_STRING("getMaximumPoolSize"), jint>(); }
inline void ThreadPoolExecutor::setKeepAliveTime(jlong time, ref<java::util::concurrent::TimeUnit> p2) { return call_method<SCAPIX_META_STRING("setKeepAliveTime"), void>(time, p2); }
inline jlong ThreadPoolExecutor::getKeepAliveTime(ref<java::util::concurrent::TimeUnit> unit) { return call_method<SCAPIX_META_STRING("getKeepAliveTime"), jlong>(unit); }
inline ref<java::util::concurrent::BlockingQueue> ThreadPoolExecutor::getQueue() { return call_method<SCAPIX_META_STRING("getQueue"), ref<java::util::concurrent::BlockingQueue>>(); }
inline jboolean ThreadPoolExecutor::remove(ref<java::lang::Runnable> task) { return call_method<SCAPIX_META_STRING("remove"), jboolean>(task); }
inline void ThreadPoolExecutor::purge() { return call_method<SCAPIX_META_STRING("purge"), void>(); }
inline jint ThreadPoolExecutor::getPoolSize() { return call_method<SCAPIX_META_STRING("getPoolSize"), jint>(); }
inline jint ThreadPoolExecutor::getActiveCount() { return call_method<SCAPIX_META_STRING("getActiveCount"), jint>(); }
inline jint ThreadPoolExecutor::getLargestPoolSize() { return call_method<SCAPIX_META_STRING("getLargestPoolSize"), jint>(); }
inline jlong ThreadPoolExecutor::getTaskCount() { return call_method<SCAPIX_META_STRING("getTaskCount"), jlong>(); }
inline jlong ThreadPoolExecutor::getCompletedTaskCount() { return call_method<SCAPIX_META_STRING("getCompletedTaskCount"), jlong>(); }
inline ref<java::lang::String> ThreadPoolExecutor::toString() { return call_method<SCAPIX_META_STRING("toString"), ref<java::lang::String>>(); }

} // namespace java::util::concurrent
} // namespace scapix::java_api

#endif // SCAPIX_JAVA_UTIL_CONCURRENT_THREADPOOLEXECUTOR_H
