// Generated by Scapix Java API
// https://www.scapix.com

#include <scapix/java_api/java/lang/Object.h>

#ifndef SCAPIX_ANDROID_OPENGL_MATRIX_H
#define SCAPIX_ANDROID_OPENGL_MATRIX_H

namespace scapix::java_api {
namespace android::opengl {

class Matrix : public object_base<SCAPIX_META_STRING("android/opengl/Matrix"),
	java::lang::Object>
{
public:

	static ref<Matrix> new_object();
	static void multiplyMM(ref<link::java::array<jfloat>> p1, jint p2, ref<link::java::array<jfloat>> p3, jint p4, ref<link::java::array<jfloat>> p5, jint p6);
	static void multiplyMV(ref<link::java::array<jfloat>> p1, jint p2, ref<link::java::array<jfloat>> p3, jint p4, ref<link::java::array<jfloat>> p5, jint p6);
	static void transposeM(ref<link::java::array<jfloat>> mTrans, jint mTransOffset, ref<link::java::array<jfloat>> m, jint mOffset);
	static jboolean invertM(ref<link::java::array<jfloat>> mInv, jint mInvOffset, ref<link::java::array<jfloat>> m, jint mOffset);
	static void orthoM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat left, jfloat right, jfloat bottom, jfloat top, jfloat near, jfloat far);
	static void frustumM(ref<link::java::array<jfloat>> m, jint offset, jfloat left, jfloat right, jfloat bottom, jfloat top, jfloat near, jfloat far);
	static void perspectiveM(ref<link::java::array<jfloat>> m, jint offset, jfloat fovy, jfloat aspect, jfloat zNear, jfloat zFar);
	static jfloat length(jfloat x, jfloat y, jfloat z);
	static void setIdentityM(ref<link::java::array<jfloat>> sm, jint smOffset);
	static void scaleM(ref<link::java::array<jfloat>> sm, jint smOffset, ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z);
	static void scaleM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z);
	static void translateM(ref<link::java::array<jfloat>> tm, jint tmOffset, ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z);
	static void translateM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z);
	static void rotateM(ref<link::java::array<jfloat>> rm, jint rmOffset, ref<link::java::array<jfloat>> m, jint mOffset, jfloat a, jfloat x, jfloat y, jfloat z);
	static void rotateM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat a, jfloat x, jfloat y, jfloat z);
	static void setRotateM(ref<link::java::array<jfloat>> rm, jint rmOffset, jfloat a, jfloat x, jfloat y, jfloat z);
	static void setRotateEulerM(ref<link::java::array<jfloat>> rm, jint rmOffset, jfloat x, jfloat y, jfloat z);
	static void setLookAtM(ref<link::java::array<jfloat>> rm, jint rmOffset, jfloat eyeX, jfloat eyeY, jfloat eyeZ, jfloat centerX, jfloat centerY, jfloat centerZ, jfloat upX, jfloat upY, jfloat upZ);

protected:

	Matrix(handle_type h) : base_(h) {}

};

} // namespace android::opengl
} // namespace scapix::java_api


namespace scapix::java_api {
namespace android::opengl {

inline ref<Matrix> Matrix::new_object() { return base_::new_object(); }
inline void Matrix::multiplyMM(ref<link::java::array<jfloat>> p1, jint p2, ref<link::java::array<jfloat>> p3, jint p4, ref<link::java::array<jfloat>> p5, jint p6) { return call_static_method<SCAPIX_META_STRING("multiplyMM"), void>(p1, p2, p3, p4, p5, p6); }
inline void Matrix::multiplyMV(ref<link::java::array<jfloat>> p1, jint p2, ref<link::java::array<jfloat>> p3, jint p4, ref<link::java::array<jfloat>> p5, jint p6) { return call_static_method<SCAPIX_META_STRING("multiplyMV"), void>(p1, p2, p3, p4, p5, p6); }
inline void Matrix::transposeM(ref<link::java::array<jfloat>> mTrans, jint mTransOffset, ref<link::java::array<jfloat>> m, jint mOffset) { return call_static_method<SCAPIX_META_STRING("transposeM"), void>(mTrans, mTransOffset, m, mOffset); }
inline jboolean Matrix::invertM(ref<link::java::array<jfloat>> mInv, jint mInvOffset, ref<link::java::array<jfloat>> m, jint mOffset) { return call_static_method<SCAPIX_META_STRING("invertM"), jboolean>(mInv, mInvOffset, m, mOffset); }
inline void Matrix::orthoM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat left, jfloat right, jfloat bottom, jfloat top, jfloat near, jfloat far) { return call_static_method<SCAPIX_META_STRING("orthoM"), void>(m, mOffset, left, right, bottom, top, near, far); }
inline void Matrix::frustumM(ref<link::java::array<jfloat>> m, jint offset, jfloat left, jfloat right, jfloat bottom, jfloat top, jfloat near, jfloat far) { return call_static_method<SCAPIX_META_STRING("frustumM"), void>(m, offset, left, right, bottom, top, near, far); }
inline void Matrix::perspectiveM(ref<link::java::array<jfloat>> m, jint offset, jfloat fovy, jfloat aspect, jfloat zNear, jfloat zFar) { return call_static_method<SCAPIX_META_STRING("perspectiveM"), void>(m, offset, fovy, aspect, zNear, zFar); }
inline jfloat Matrix::length(jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("length"), jfloat>(x, y, z); }
inline void Matrix::setIdentityM(ref<link::java::array<jfloat>> sm, jint smOffset) { return call_static_method<SCAPIX_META_STRING("setIdentityM"), void>(sm, smOffset); }
inline void Matrix::scaleM(ref<link::java::array<jfloat>> sm, jint smOffset, ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("scaleM"), void>(sm, smOffset, m, mOffset, x, y, z); }
inline void Matrix::scaleM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("scaleM"), void>(m, mOffset, x, y, z); }
inline void Matrix::translateM(ref<link::java::array<jfloat>> tm, jint tmOffset, ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("translateM"), void>(tm, tmOffset, m, mOffset, x, y, z); }
inline void Matrix::translateM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("translateM"), void>(m, mOffset, x, y, z); }
inline void Matrix::rotateM(ref<link::java::array<jfloat>> rm, jint rmOffset, ref<link::java::array<jfloat>> m, jint mOffset, jfloat a, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("rotateM"), void>(rm, rmOffset, m, mOffset, a, x, y, z); }
inline void Matrix::rotateM(ref<link::java::array<jfloat>> m, jint mOffset, jfloat a, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("rotateM"), void>(m, mOffset, a, x, y, z); }
inline void Matrix::setRotateM(ref<link::java::array<jfloat>> rm, jint rmOffset, jfloat a, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("setRotateM"), void>(rm, rmOffset, a, x, y, z); }
inline void Matrix::setRotateEulerM(ref<link::java::array<jfloat>> rm, jint rmOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<SCAPIX_META_STRING("setRotateEulerM"), void>(rm, rmOffset, x, y, z); }
inline void Matrix::setLookAtM(ref<link::java::array<jfloat>> rm, jint rmOffset, jfloat eyeX, jfloat eyeY, jfloat eyeZ, jfloat centerX, jfloat centerY, jfloat centerZ, jfloat upX, jfloat upY, jfloat upZ) { return call_static_method<SCAPIX_META_STRING("setLookAtM"), void>(rm, rmOffset, eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ); }

} // namespace android::opengl
} // namespace scapix::java_api

#endif // SCAPIX_ANDROID_OPENGL_MATRIX_H
